<h2 data-v-md-heading="前言" data-v-md-line="1">前言</h2>
<p data-v-md-line="3">这篇文章主要是 <strong>总结 + 实践</strong> 一些比较常见且重要的JS手写题，方便自己以及大家学习参考。</p>
<h2 data-v-md-heading="_1-数据类型判断" data-v-md-line="5">1. 数据类型判断</h2>
<p data-v-md-line="7"><strong>核心思想</strong>：<code>typeof</code> 可以判断 <code>Undefined、String、Number、Boolean、Symbol、Function</code>类型的数据，但对其他的都会认为是<code>Object</code>，比如<code>Null、Array</code>等。所以通过<code>typeof</code>来判断数据类型会不准确。</p>
<p data-v-md-line="9"><strong>解决方法</strong>：可以通过<code>Object.prototype.toString</code>解决。</p>
<p data-v-md-line="11"><strong>实现</strong>：</p>
<div data-v-md-line="13"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mytypeof</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>).toLowerCase();
}
复制代码
</code></pre>
</div></div><ol data-v-md-line="20">
<li>使用<code>call</code> 是为了绑定 <code>this</code> 到 <code>obj</code> 上</li>
<li>使用<code>slice</code> 是因为这前面返回的结果是类似<code>[Object xxx]</code>这样的, <code>xxx</code> 是根据 <code>obj</code> 的类型变化的</li>
<li>使用<code>toLowerCase</code> 是因为原生<code>typeof</code>的返回结果的第一个字母是小写字母。</li>
</ol>
<h2 data-v-md-heading="_2-继承" data-v-md-line="24">2. 继承</h2>
<h3 data-v-md-heading="_2-1-原型继承" data-v-md-line="26">2.1 原型继承</h3>
<p data-v-md-line="28"><strong>核心思想</strong>：子类的原型成为父类的实例</p>
<p data-v-md-line="30"><strong>实现</strong>：</p>
<div data-v-md-line="32"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>];
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-comment">// 原型继承关键: 子类的原型成为父类的实例</span>
SubType.prototype = <span class="hljs-keyword">new</span> SuperType();

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> SubType();
instance1.colors.push(<span class="hljs-string">'blue'</span>);

<span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> SubType();
<span class="hljs-built_in">console</span>.log(instance2.colors);  <span class="hljs-comment">// ['red', 'green', 'blue']</span>
复制代码
</code></pre>
</div></div><p data-v-md-line="49"><strong>原型继承存在的问题</strong>：</p>
<ol data-v-md-line="51">
<li>原型中包含的引用类型属性将被所有实例对象共享</li>
<li>子类在实例化时不能给父类构造函数传参</li>
</ol>
<h3 data-v-md-heading="_2-2-构造函数继承" data-v-md-line="54">2.2 构造函数继承</h3>
<p data-v-md-line="56"><strong>核心思想</strong>：在子类构造函数中调用父类构造函数</p>
<p data-v-md-line="58"><strong>实现</strong>：</p>
<div data-v-md-line="60"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>];
    <span class="hljs-built_in">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;
    }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-comment">// 继承 SuperType 并传参</span>
    SuperType.call(<span class="hljs-built_in">this</span>, name);
}

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">'instance1'</span>);
instance1.colors.push(<span class="hljs-string">'blue'</span>);
<span class="hljs-built_in">console</span>.log(instance1.colors); <span class="hljs-comment">// ['red','green','blue']</span>

<span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">'instance2'</span>);
<span class="hljs-built_in">console</span>.log(instance2.colors);  <span class="hljs-comment">// ['red', 'green']</span>
复制代码
</code></pre>
</div></div><p data-v-md-line="83"><strong>构造函数继承</strong>的出现是为了解决了原型继承的引用值共享问题。优点是可以在子类构造函数中向父类构造函数传参。它存在的问题是：1)由于方法必须在构造函数中定义，因此方法不能重用。2)子类也不能访问父类原型上定义的方法。</p>
<h3 data-v-md-heading="_2-3-组合继承" data-v-md-line="85">2.3 组合继承</h3>
<p data-v-md-line="87"><strong>核心思想</strong>：综合了原型链和构造函数，即，使用原型链继承原型上的方法，而通过构造函数继承实例属性。</p>
<p data-v-md-line="89"><strong>实现</strong>：</p>
<div data-v-md-line="91"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>];
}
Super.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>) </span>{
    <span class="hljs-comment">// 继承属性</span>
    SuperType.call(<span class="hljs-built_in">this</span>, name);
    <span class="hljs-comment">// 实例属性</span>
    <span class="hljs-built_in">this</span>.age = age;
}
<span class="hljs-comment">// 继承方法</span>
SubType.prototype = <span class="hljs-keyword">new</span> SuperType();

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">'instance1'</span>, <span class="hljs-number">1</span>);
instance1.sayName();  <span class="hljs-comment">// "instance1"</span>
instance1.colors.push(<span class="hljs-string">"blue"</span>);
<span class="hljs-built_in">console</span>.log(instance1.colors); <span class="hljs-comment">// ['red','green','blue']</span>

<span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">'instance2'</span>, <span class="hljs-number">2</span>);
instance2.sayName();  <span class="hljs-comment">// "instance2"</span>
<span class="hljs-built_in">console</span>.log(instance2.colors); <span class="hljs-comment">// ['red','green']</span>
复制代码
</code></pre>
</div></div><p data-v-md-line="120"><strong>组合继承</strong>存在的问题是：父类构造函数始终会被调用两次：一次是在创建子类原型时<code>new SuperType()</code>调用，另一次是在子类构造函数中<code>SuperType.call()</code>调用。</p>
<h3 data-v-md-heading="_2-4-寄生式组合继承-最佳" data-v-md-line="122">2.4 寄生式组合继承(最佳)</h3>
<p data-v-md-line="124"><strong>核心思想</strong>：通过构造函数继承属性，但使用混合式原型继承方法，即，不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。</p>
<p data-v-md-line="126"><strong>实现</strong>：</p>
<div data-v-md-line="128"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>];
}
Super.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>) </span>{
    <span class="hljs-comment">// 继承属性</span>
    SuperType.call(<span class="hljs-built_in">this</span>, name);
    <span class="hljs-built_in">this</span>.age = age;
}
<span class="hljs-comment">// 继承方法</span>
SubType.prototype = <span class="hljs-built_in">Object</span>.create(SuperType.prototype);
<span class="hljs-comment">// 重写原型导致默认 constructor 丢失，手动将 constructor 指回 SubType</span>
SubType.prototype.constructor = SubType;
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_2-5-class-实现继承-es6" data-v-md-line="148">2.5 class 实现继承(ES6)</h3>
<p data-v-md-line="150"><strong>核心思想</strong>：通过 <code>extends</code> 来实现类的继承(相当于 <code>ES5</code> 的原型继承)。通过 <code>super</code> 调用父类的构造方法 (相当于 <code>ES5</code> 的构造函数继承)。</p>
<p data-v-md-line="152"><strong>实现</strong>：</p>
<div data-v-md-line="154"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperType</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }
    <span class="hljs-function"><span class="hljs-title">sayName</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubType</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperType</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> {
        <span class="hljs-built_in">super</span>(name);  <span class="hljs-comment">// 继承属性</span>
        <span class="hljs-built_in">this</span>.age = age;
    }
}

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">'instance'</span>, <span class="hljs-number">0</span>);
instance.sayName();  <span class="hljs-comment">// "instance"</span>
复制代码
</code></pre>
</div></div><p data-v-md-line="176">虽然类继承使用的是新语法，但背后依旧使用的是原型链。</p>
<h2 data-v-md-heading="_3-数组去重" data-v-md-line="178">3. 数组去重</h2>
<h3 data-v-md-heading="_3-1-使用-indexof-includes-实现" data-v-md-line="180">3.1 使用 indexOf/includes 实现</h3>
<div data-v-md-line="182"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">var</span> res = [];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        <span class="hljs-keyword">if</span>(res.indexOf(arr[i]) === -<span class="hljs-number">1</span>) res.push(arr[i]);
        <span class="hljs-comment">// if(!res.includes(arr[i])) res.push(arr[i]);</span>
    }
    <span class="hljs-keyword">return</span> res;
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_3-2-使用-filter-foreach-indexof-includes-实现" data-v-md-line="194">3.2 使用 filter(forEach) + indexOf/includes 实现</h3>
<div data-v-md-line="196"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-comment">// filter</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">var</span> res = arr.filter(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> {
        <span class="hljs-comment">// 只存第一个出现的元素</span>
        <span class="hljs-keyword">return</span> arr.indexOf(value) === index;
    });
    <span class="hljs-keyword">return</span> res;
}
<span class="hljs-comment">// forEach</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">var</span> res = [];
    arr.forEach(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span>(!res.includes(value)) res.push(value);
    });
    <span class="hljs-keyword">return</span> res;
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_3-3-非-api-版本-原生-实现" data-v-md-line="216">3.3 非 API 版本（原生）实现</h3>
<div data-v-md-line="218"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">var</span> res = [];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        <span class="hljs-keyword">var</span> flag = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; res.length; j++) {
            <span class="hljs-keyword">if</span>(arr[i] === res[j]) {
                flag = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">if</span>(flag === <span class="hljs-literal">false</span>) res.push(arr[i]);
    }
    <span class="hljs-keyword">return</span> res;
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_3-4-es6-使用-set-扩展运算符-array-from-实现" data-v-md-line="236">3.4 ES6 使用 Set + 扩展运算符(…)/Array.from() 实现</h3>
<div data-v-md-line="238"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-comment">// return [...new Set(arr)];</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr));
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_4-数组扁平化" data-v-md-line="246">4. 数组扁平化</h2>
<h3 data-v-md-heading="_4-1-es5-递归写法-isarray-、concat" data-v-md-line="248">4.1 ES5 递归写法 —— isArray()、concat()</h3>
<div data-v-md-line="250"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat11</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">var</span> res = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arr[i])) {
            res = res.concat(flat11(arr[i]));
        } <span class="hljs-keyword">else</span> {
            res.push(arr[i]);
        }
    }
    <span class="hljs-keyword">return</span> res;
}
复制代码
</code></pre>
</div></div><p data-v-md-line="265">如果想实现第二个参数（指定“拉平”的层数），可以这样实现，后面的几种可以自己类似实现：</p>
<div data-v-md-line="267"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">arr, level = <span class="hljs-number">1</span></span>) </span>{
    <span class="hljs-keyword">var</span> res = [];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(arr[i]) || level &gt;= <span class="hljs-number">1</span>) {
            res = res.concat(flat(arr[i]), level - <span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">else</span> {
            res.push(arr[i]);
        }
    }
    <span class="hljs-keyword">return</span> res;
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_4-2-es6-递归写法-reduce-、concat-、isarray" data-v-md-line="283">4.2 ES6 递归写法 — reduce()、concat()、isArray()</h3>
<div data-v-md-line="285"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">return</span> arr.reduce(
        <span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> pre.concat(<span class="hljs-built_in">Array</span>.isArray(cur) ? flat(cur) : cur), []
    );
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_4-3-es6-迭代写法-扩展运算符-、some-、concat-、isarray" data-v-md-line="294">4.3 ES6 迭代写法 — 扩展运算符(…)、some()、concat()、isArray()</h3>
<p data-v-md-line="296">ES6 的扩展运算符(…) 只能扁平化一层</p>
<div data-v-md-line="298"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">return</span> [].concat(...arr);
}
复制代码
</code></pre>
</div></div><p data-v-md-line="305"><strong>全部扁平化</strong>：遍历原数组，若<code>arr</code>中含有数组则使用一次扩展运算符，直至没有为止。</p>
<div data-v-md-line="307"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">while</span>(arr.some(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">Array</span>.isArray(item))) {
        arr = [].concat(...arr);
    }
    <span class="hljs-keyword">return</span> arr;
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_4-4-tostring-join-split" data-v-md-line="317">4.4 toString/join &amp; split</h3>
<p data-v-md-line="319">调用数组的 <code>toString()/join()</code> 方法（它会自动扁平化处理），将数组变为字符串然后再用 <code>split</code> 分割还原为数组。由于 <code>split</code> 分割后形成的数组的每一项值为字符串，所以需要用一个<code>map</code>方法遍历数组将其每一项转换为数值型。</p>
<div data-v-md-line="321"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">arr</span>)</span>{
    <span class="hljs-keyword">return</span> arr.toString().split(<span class="hljs-string">','</span>).map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">Number</span>(item));
    <span class="hljs-comment">// return arr.join().split(',').map(item =&gt; Number(item));</span>
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_4-5-使用正则" data-v-md-line="329">4.5 使用正则</h3>
<p data-v-md-line="331"><code>JSON.stringify(arr).replace(/[|]/g, '')</code> 会先将数组<code>arr</code>序列化为字符串，然后使用 <code>replace()</code> 方法将字符串中所有的<code>[</code> 或 <code>]</code> 替换成空字符，从而达到扁平化处理，此时的结果为 <code>arr</code> 不包含 <code>[]</code> 的字符串。最后通过<code>JSON.parse()</code> 解析字符串。</p>
<div data-v-md-line="333"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">"["</span> + <span class="hljs-built_in">JSON</span>.stringify(arr).replace(<span class="hljs-regexp">/\[|\]/g</span>,<span class="hljs-string">''</span>) + <span class="hljs-string">"]"</span>);
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_5-类数组转化为数组" data-v-md-line="340">5. 类数组转化为数组</h2>
<p data-v-md-line="342">类数组是具有 <code>length</code> 属性，但不具有数组原型上的方法。常见的类数组有 <code>arguments</code>、DOM 操作方法返回的结果(如<code>document.querySelectorAll('div')</code>)等。</p>
<h3 data-v-md-heading="_5-1-扩展运算符" data-v-md-line="344">5.1 扩展运算符(…)</h3>
<p data-v-md-line="346"><strong>注意</strong>：扩展运算符只能作用于 <code>iterable</code> 对象，即拥有 <code>Symbol(Symbol.iterator)</code> 属性值。</p>
<div data-v-md-line="348"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-keyword">let</span> arr = [...arrayLike]
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_5-2-array-from" data-v-md-line="353">5.2 Array.from()</h3>
<div data-v-md-line="355"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>.from(arrayLike);
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_5-3-array-prototype-slice-call" data-v-md-line="360">5.3 Array.prototype.slice.call()</h3>
<div data-v-md-line="362"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike);
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_5-4-array-apply" data-v-md-line="367">5.4 Array.apply()</h3>
<div data-v-md-line="369"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, arrayLike);
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_5-5-concat-apply" data-v-md-line="374">5.5 concat + apply</h3>
<div data-v-md-line="376"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>.prototype.concat.apply([], arrayLike);
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_6-实现数组原型方法" data-v-md-line="381">6. 实现数组原型方法</h2>
<h3 data-v-md-heading="_6-1-foreach" data-v-md-line="383">6.1 forEach</h3>
<blockquote data-v-md-line="385">
<p data-v-md-line="385">语法：<code>arr.forEach(callback(currentValue [, index [, array]])[, thisArg])</code></p>
<p data-v-md-line="387">参数：</p>
<blockquote data-v-md-line="389">
<p data-v-md-line="389"><code>callback</code>：为数组中每个元素执行的函数，该函数接受1-3个参数</p>
<blockquote data-v-md-line="391">
<p data-v-md-line="391"><code>currentValue</code>: 数组中正在处理的当前元素</p>
<p data-v-md-line="393"><code>index</code>(可选): 数组中正在处理的当前元素的索引</p>
<p data-v-md-line="395"><code>array</code>(可选): <code>forEach()</code> 方法正在操作的数组 <code>thisArg</code>(可选): 当执行回调函数 <code>callback</code> 时，用作 <code>this</code> 的值。</p>
</blockquote>
</blockquote>
<p data-v-md-line="397">返回值：<code>undefined</code></p>
</blockquote>
<div data-v-md-line="399"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Array</span>.prototype.forEach1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'this is null or not defined'</span>);
    }
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">"function"</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">'is not a function'</span>);
    }
    <span class="hljs-comment">// 创建一个新的 Object 对象。该对象将会包裹(wrapper)传入的参数 this(当前数组)。</span>
    <span class="hljs-keyword">const</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>);
    <span class="hljs-comment">// O.length &gt;&gt;&gt; 0 无符号右移 0 位</span>
    <span class="hljs-comment">// 意义：为了保证转换后的值为正整数。</span>
    <span class="hljs-comment">// 其实底层做了 2 层转换，第一是非 number 转成 number 类型，第二是将 number 转成 Uint32 类型</span>
    <span class="hljs-keyword">const</span> len = O.length &gt;&gt;&gt; <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(k &lt; len) {
        <span class="hljs-keyword">if</span>(k <span class="hljs-keyword">in</span> O) {
            callback.call(thisArg, O[k], k, O);
        }
        k++;
    }
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_6-2-map" data-v-md-line="424">6.2 map</h3>
<blockquote data-v-md-line="426">
<p data-v-md-line="426">语法： <code>arr.map(callback(currentValue [, index [, array]])[, thisArg])</code></p>
<p data-v-md-line="428">参数：与 <code>forEach()</code> 方法一样</p>
<p data-v-md-line="430">返回值：一个由原数组每个元素执行回调函数的结果组成的新数组。</p>
</blockquote>
<div data-v-md-line="432"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Array</span>.prototype.map1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'this is null or not defined'</span>);
    }
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">"function"</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">'is not a function'</span>);
    }
    <span class="hljs-keyword">const</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>); 
    <span class="hljs-keyword">const</span> len = O.length &gt;&gt;&gt; <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> newArr = [];  <span class="hljs-comment">// 返回的新数组</span>
    <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(k &lt; len) {
        <span class="hljs-keyword">if</span>(k <span class="hljs-keyword">in</span> O) {
            newArr[k] = callback.call(thisArg, O[k], k, O);
        }
        k++;
    }
    <span class="hljs-keyword">return</span> newArr;
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_6-3-filter" data-v-md-line="455">6.3 filter</h3>
<blockquote data-v-md-line="457">
<p data-v-md-line="457">语法：<code>arr.filter(callback(element [, index [, array]])[, thisArg])</code></p>
<p data-v-md-line="459">参数：</p>
<blockquote data-v-md-line="461">
<p data-v-md-line="461"><code>callback</code>: 用来测试数组的每个元素的函数。返回 <code>true</code> 表示该元素通过测试，保留该元素，<code>false</code> 则不保留。它接受以下三个参数：<code>element、index、array</code>，参数的意义与 <code>forEach</code> 一样。</p>
<p data-v-md-line="463"><code>thisArg</code>(可选): 执行 <code>callback</code> 时，用于 <code>this</code> 的值。</p>
</blockquote>
<p data-v-md-line="465">返回值：一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</p>
</blockquote>
<div data-v-md-line="467"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Array</span>.prototype.filter1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'this is null or not defined'</span>);
    }
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">"function"</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">'is not a function'</span>);
    }
    <span class="hljs-keyword">const</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>); 
    <span class="hljs-keyword">const</span> len = O.length &gt;&gt;&gt; <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> newArr = [];  <span class="hljs-comment">// 返回的新数组</span>
    <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(k &lt; len) {
        <span class="hljs-keyword">if</span>(k <span class="hljs-keyword">in</span> O) {
            <span class="hljs-keyword">if</span>(callback.call(thisArg, O[k], k, O)) {
                newArr.push(O[k]);
            }
        }
        k++;
    }
    <span class="hljs-keyword">return</span> newArr;
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_6-4-some" data-v-md-line="492">6.4 some</h3>
<blockquote data-v-md-line="494">
<p data-v-md-line="494">语法：<code>arr.some(callback(element [, index [, array]])[, thisArg])</code></p>
<p data-v-md-line="496">参数：</p>
<blockquote data-v-md-line="498">
<p data-v-md-line="498"><code>callback</code>: 用来测试数组的每个元素的函数。接受以下三个参数：element、index、array，参数的意义与 forEach 一样。</p>
<p data-v-md-line="500"><code>thisArg</code>(可选): 执行 <code>callback</code> 时，用于 <code>this</code> 的值。 返回值：数组中有至少一个元素通过回调函数的测试就会返回 <strong>true</strong>；所有元素都没有通过回调函数的测试返回值才会为 <strong>false</strong>。</p>
</blockquote>
</blockquote>
<div data-v-md-line="502"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Array</span>.prototype.some1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'this is null or not defined'</span>);
    }
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">"function"</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">'is not a function'</span>);
    }
    <span class="hljs-keyword">const</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>); 
    <span class="hljs-keyword">const</span> len = O.length &gt;&gt;&gt; <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(k &lt; len) {
        <span class="hljs-keyword">if</span>(k <span class="hljs-keyword">in</span> O) {
            <span class="hljs-keyword">if</span>(callback.call(thisArg, O[k], k, O)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
            }
        }
        k++;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_6-5-reduce" data-v-md-line="526">6.5 reduce</h3>
<blockquote data-v-md-line="528">
<p data-v-md-line="528">语法：<code>arr.reduce(callback(preVal, curVal[, curIndex [, array]])[, initialValue])</code></p>
<p data-v-md-line="530">参数：</p>
<blockquote data-v-md-line="532">
<p data-v-md-line="532"><code>callback</code>: 一个 “reducer” 函数，包含四个参数：</p>
<blockquote data-v-md-line="534">
<p data-v-md-line="534"><code>preVal</code>：上一次调用 <code>callback</code> 时的返回值。在第一次调用时，若指定了初始值 <code>initialValue</code>，其值则为 <code>initialValue</code>，否则为数组索引为 0 的元素 <code>array[0]</code>。</p>
<p data-v-md-line="536"><code>curVal</code>：数组中正在处理的元素。在第一次调用时，若指定了初始值 <code>initialValue</code>，其值则为数组索引为 0 的元素 <code>array[0]</code>，否则为 <code>array[1]</code>。</p>
<p data-v-md-line="538"><code>curIndex</code>(可选)：数组中正在处理的元素的索引。若指定了初始值 <code>initialValue</code>，则起始索引号为 0，否则从索引 1 起始。</p>
<p data-v-md-line="540"><code>array</code>(可选)：用于遍历的数组。 initialValue(可选): 作为第一次调用 <code>callback</code> 函数时参数 <code>preVal</code> 的值。若指定了初始值 <code>initialValue</code>，则 <code>curVal</code> 则将使用数组第一个元素；否则 <code>preVal</code> 将使用数组第一个元素，而 <code>curVal</code> 将使用数组第二个元素。 返回值：使用 “reducer” 回调函数遍历整个数组后的结果。</p>
</blockquote>
</blockquote>
</blockquote>
<div data-v-md-line="542"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Array</span>.prototype.reduce1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, initialValue</span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'this is null or not defined'</span>);
    }
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">"function"</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">'is not a function'</span>);
    }
    <span class="hljs-keyword">const</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>);
    <span class="hljs-keyword">const</span> len = O.length &gt;&gt;&gt; <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> accumulator = initialValue;
    <span class="hljs-comment">// 如果第二个参数为undefined的情况下，则数组的第一个有效值（非empty）作为累加器的初始值</span>
    <span class="hljs-keyword">if</span>(accumulator === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">while</span>(k &lt; len &amp;&amp; !(k <span class="hljs-keyword">in</span> O)) {
            k++;
        }
        <span class="hljs-comment">// 如果超出数组界限还没有找到累加器的初始值，则TypeError</span>
        <span class="hljs-keyword">if</span>(k &gt;= len) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Reduce of empty array with no initial value'</span>);
        }
        accumulator = O[k++];
    }
    <span class="hljs-keyword">while</span>(k &lt; len) {
        <span class="hljs-keyword">if</span>(k <span class="hljs-keyword">in</span> O) {
            accumulator = callback(accumulator, O[k], k, O);
        }
        k++;
    }
    <span class="hljs-keyword">return</span> accumulator;
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_7-call-apply-bind-的实现" data-v-md-line="576">7. call/apply/bind 的实现</h2>
<h3 data-v-md-heading="_7-1-call" data-v-md-line="578">7.1 call</h3>
<p data-v-md-line="580"><strong>描述</strong>：使用 <strong>一个指定的 <code>this</code> 值(默认为 <code>window</code>)</strong> 和 <strong>一个或多个参数</strong> 来调用一个函数。</p>
<p data-v-md-line="582"><strong>语法</strong>：<code>function.call(thisArg, arg1, arg2, ...)</code></p>
<p data-v-md-line="584"><strong>核心思想</strong>：</p>
<ul data-v-md-line="586">
<li>调用call 的可能不是函数</li>
<li>this 可能传入 null</li>
<li>传入不固定个数的参数</li>
<li>给对象绑定函数并调用</li>
<li>删除绑定的函数</li>
<li>函数可能有返回值</li>
</ul>
<p data-v-md-line="593"><strong>实现</strong>：</p>
<div data-v-md-line="595"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Function</span>.prototype.call1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context, ...args</span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">"function"</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"this is not a function"</span>);
    }
    context = context || <span class="hljs-built_in">window</span>; <span class="hljs-comment">// 如果传入的是null, 则指向window</span>
    <span class="hljs-keyword">let</span> fn = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'fn'</span>);  <span class="hljs-comment">// 创造唯一的key值,作为构造的context内部方法名</span>
    context[fn] = <span class="hljs-built_in">this</span>;  <span class="hljs-comment">// 为 context 绑定原函数(this)</span>
    <span class="hljs-keyword">let</span> res = context[fn](...args); <span class="hljs-comment">// 调用原函数并传参, 保存返回值用于call返回</span>
    <span class="hljs-keyword">delete</span> context[fn];  <span class="hljs-comment">// 删除对象中的函数, 不能修改对象</span>
    <span class="hljs-keyword">return</span> res;
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_7-2-apply" data-v-md-line="610">7.2 apply</h3>
<p data-v-md-line="612"><strong>描述</strong>：与 <code>call</code> 类似，唯一的区别就是 <code>call</code> 是传入不固定个数的参数，而 <code>apply</code> 是传入一个参数数组或类数组。</p>
<p data-v-md-line="614"><strong>实现</strong>：</p>
<div data-v-md-line="616"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Function</span>.prototype.apply1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context, arr</span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">"function"</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"this is not a function"</span>);
    }
    context = context || <span class="hljs-built_in">window</span>; <span class="hljs-comment">// 如果传入的是null, 则指向window</span>
    <span class="hljs-keyword">let</span> fn = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'fn'</span>);  <span class="hljs-comment">// 创造唯一的key值，作为构造的context内部方法名</span>
    context[fn] = <span class="hljs-built_in">this</span>;  <span class="hljs-comment">// 为 context 绑定原函数(this)</span>
    <span class="hljs-keyword">let</span> res;
    <span class="hljs-comment">// 判断是否传入的数组是否为空</span>
    <span class="hljs-keyword">if</span>(!arr) {
        res = context[fn]();
    }
    <span class="hljs-keyword">else</span> {
        res = context[fn](...arr); <span class="hljs-comment">// 调用原函数并传参, 保存返回值用于call返回</span>
    }
    <span class="hljs-keyword">delete</span> context[fn];  <span class="hljs-comment">// 删除对象中的函数, 不能修改对象</span>
    <span class="hljs-keyword">return</span> res;
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_7-3-bind" data-v-md-line="638">7.3 bind</h3>
<p data-v-md-line="640"><strong>描述</strong>：<code>bind</code> 方法会创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<p data-v-md-line="642"><strong>核心思想</strong>:</p>
<ul data-v-md-line="644">
<li>调用bind的可能不是函数</li>
<li>bind() 除了 this 外，还可传入多个参数</li>
<li>bind() 创建的新函数可能传入多个参数</li>
<li>新函数可能被当做构造函数调用</li>
<li>函数可能有返回值</li>
</ul>
<p data-v-md-line="650"><strong>实现</strong>：</p>
<div data-v-md-line="652"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Function</span>.prototype.bind1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context, ...args</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> that !== <span class="hljs-string">"function"</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"this is not function"</span>);
    }
    <span class="hljs-keyword">let</span> that = <span class="hljs-built_in">this</span>;  <span class="hljs-comment">// 保存原函数（this）</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params">...innerArgs</span>) </span>{
        <span class="hljs-comment">// 判断是否是 new 构造函数</span>
        <span class="hljs-comment">// 由于这里是调用的 call 方法，因此不需要判断 context 是否为空</span>
        <span class="hljs-keyword">return</span> that.call(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> F ? <span class="hljs-built_in">this</span> : context, ...args, ...innerArgs);
    }
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_8-new-实现" data-v-md-line="667">8. new 实现</h2>
<p data-v-md-line="669"><strong>描述</strong>：<code>new</code> 运算符用来创建用户自定义的对象类型的实例或者具有构造函数的内置对象的实例。</p>
<p data-v-md-line="671"><strong>核心思想</strong>:</p>
<ul data-v-md-line="673">
<li>new 会产生一个新对象</li>
<li>新对象需要能够访问到构造函数的属性，所以需要重新指定它的原型</li>
<li>构造函数可能会显示返回对象与基本类型的情况(以及null)</li>
</ul>
<p data-v-md-line="677"><strong>步骤</strong>：使用<code>new</code>命令时，它后面的函数依次执行下面的步骤:</p>
<ol data-v-md-line="679">
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的隐式原型(<code>__proto__</code>)，指向构造函数的<code>prototype</code>属性。</li>
<li>让函数内部的<code>this</code>关键字指向这个对象。开始执行构造函数内部的代码（为这个新对象添加属性）。</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li>
</ol>
<p data-v-md-line="684"><strong>实现</strong>：</p>
<div data-v-md-line="686"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-comment">// 写法一：</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 将 arguments 对象转为数组</span>
    <span class="hljs-keyword">let</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-comment">// 取出构造函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-title">constructor</span> = <span class="hljs-title">args</span>.<span class="hljs-title">shift</span>(<span class="hljs-params"></span>);
    
    <span class="hljs-comment">// 创建一个空对象，继承构造函数的 prototype 属性</span>
    <span class="hljs-keyword">let</span> obj = {};
    obj.__proto__ = <span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>;
    
    <span class="hljs-comment">// 执行构造函数并将 this 绑定到新创建的对象上</span>
    <span class="hljs-keyword">let</span> res = <span class="hljs-title">constructor</span>.<span class="hljs-title">call</span>(<span class="hljs-params">obj, ...args</span>);
    <span class="hljs-comment">// let res = constructor.apply(obj, args);</span>
    
    <span class="hljs-comment">// 判断构造函数执行返回的结果。如果返回结果是引用类型，就直接返回，否则返回 obj 对象</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">"object"</span> &amp;&amp; res !== <span class="hljs-literal">null</span>) ? res : obj;
}

<span class="hljs-comment">// 写法二：constructor：构造函数， ...args：构造函数参数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">constructor, ...args</span>) </span>{
    <span class="hljs-comment">// 生成一个空对象,继承构造函数的 prototype 属性</span>
    <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>);
    
    <span class="hljs-comment">// 执行构造函数并将 this 绑定到新创建的对象上</span>
    <span class="hljs-keyword">let</span> res = <span class="hljs-title">constructor</span>.<span class="hljs-title">call</span>(<span class="hljs-params">obj, ...args</span>);
    <span class="hljs-comment">// let res = constructor.apply(obj, args);</span>
    
    <span class="hljs-comment">// 判断构造函数执行返回的结果。如果返回结果是引用类型，就直接返回，否则返回 obj 对象</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">"object"</span> &amp;&amp; res !== <span class="hljs-literal">null</span>) ? res : obj;
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_9-函数柯里化" data-v-md-line="721">9. 函数柯里化</h2>
<p data-v-md-line="723"><strong>柯里化（currying）</strong> 指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数。</p>
<p data-v-md-line="725">对于已经柯里化后的函数来说，当接收的参数数量与原函数的形参数量相同时，执行原函数； 当接收的参数数量小于原函数的形参数量时，返回一个函数用于接收剩余的参数，直至接收的参数数量与形参数量一致，执行原函数。</p>
<h3 data-v-md-heading="_9-1-原函数形参定长-此时-fn-length-是个不变的常数" data-v-md-line="727">9.1 原函数形参定长（此时 <code>fn.length</code> 是个不变的常数）</h3>
<div data-v-md-line="729"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-comment">// 写法1-不保存参数,递归局部函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-keyword">let</span> judge = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
        <span class="hljs-comment">// 递归结束条件</span>
        <span class="hljs-keyword">if</span>(args.length === fn.length) <span class="hljs-keyword">return</span> fn(...args);
        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> judge(...args, ...arg);
    }
    <span class="hljs-keyword">return</span> judge;
}

<span class="hljs-comment">// 写法2-保存参数,递归整体函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-comment">// 保存参数，除去第一个函数参数</span>
    <span class="hljs-keyword">let</span> presentArgs = [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 返回一个新函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">// 新函数调用时会继续传参</span>
        <span class="hljs-keyword">let</span> allArgs = [...presentArgs, ...arguments];
        <span class="hljs-comment">// 递归结束条件</span>
        <span class="hljs-keyword">if</span>(allArgs.length === fn.length) {
            <span class="hljs-comment">// 如果参数够了，就执行原函数</span>
            <span class="hljs-keyword">return</span> fn(,,,allArgs);
        }
        <span class="hljs-comment">// 否则继续柯里化</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> curry(fn, ...allArgs);
    }
}

<span class="hljs-comment">// 测试</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b, c, d</span>) </span>{
  <span class="hljs-keyword">return</span> a + b + c + d;
}
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));
<span class="hljs-keyword">let</span> addCurry = curry(add);
<span class="hljs-comment">// 以下结果都返回 10</span>
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>));  
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>));
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>));
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">4</span>));
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_9-2-原函数形参不定长-此时-fn-length-为0" data-v-md-line="774">9.2 原函数形参不定长（此时 <code>fn.length</code> 为0）</h3>
<div data-v-md-line="776"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-comment">// 保存参数，除去第一个函数参数</span>
    <span class="hljs-keyword">let</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 返回一个新函数</span>
    <span class="hljs-keyword">let</span> curried = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// 新函数调用时会继续传参</span>
        <span class="hljs-keyword">let</span> allArgs = [...args, ...arguments];
        <span class="hljs-keyword">return</span> curry(fn, ...allArgs);
    };
    <span class="hljs-comment">// 利用toString隐式转换的特性，当最后执行函数时，会隐式转换</span>
    curried.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> fn(...args);
    };
    <span class="hljs-keyword">return</span> curried;
}

<span class="hljs-comment">// 测试</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...args</span>) </span>{
  <span class="hljs-keyword">return</span> args.reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> pre + cur, <span class="hljs-number">0</span>);
}
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));
<span class="hljs-keyword">let</span> addCurry = curry(add);
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>) == <span class="hljs-number">6</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">4</span>) == <span class="hljs-number">10</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)(<span class="hljs-number">1</span>).toString()); <span class="hljs-comment">// 9</span>
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// 打印 curried 函数</span>
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_10-防抖和节流" data-v-md-line="806">10. 防抖和节流</h2>
<h3 data-v-md-heading="_10-1-防抖" data-v-md-line="808">10.1 防抖</h3>
<p data-v-md-line="810"><strong>防抖(<code>debounce</code>)</strong>：触发高频事件 N 秒后只会执行一次，如果 N 秒内事件再次触发，则会重新计时。类似王者荣耀的回城功能，你反复触发回城功能，那么只认最后一次，从最后一次触发开始计时。</p>
<p data-v-md-line="812"><strong>核心思想</strong>：每次事件触发就<strong>清除原来的定时器，建立新的定时器</strong>。使用apply或call调用传入的函数。函数内部支持使用 this 和 event 对象；</p>
<p data-v-md-line="814"><strong>应用</strong>：防抖常应用于用户进行搜索输入节约请求资源，<code>window</code>触发<code>resize</code>事件时进行防抖只触发一次。</p>
<p data-v-md-line="816"><strong>实现</strong>：</p>
<div data-v-md-line="818"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>{
    <span class="hljs-comment">// 利用闭包的原理</span>
    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>{
        <span class="hljs-keyword">if</span>(timer) <span class="hljs-built_in">clearTimeout</span>(timer);
        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-comment">// 改变 this 指向为调用 debounce 所指的对象</span>
            fn.call(<span class="hljs-built_in">this</span>, ...args);
            <span class="hljs-comment">// fn.apply(this, args);</span>
        }, delay);
    }
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_10-2-节流" data-v-md-line="834">10.2 节流</h3>
<p data-v-md-line="836"><strong>节流(<code>throttle</code>)</strong>：触发高频事件，且 N 秒内只执行一次。这就好比公交车，10 分钟一趟，10 分钟内有多少人在公交站等我不管，10 分钟一到我就要发车走人！类似qq飞车的复位按钮。</p>
<p data-v-md-line="838"><strong>核心思想</strong>：使用<strong>时间戳或标志</strong>来实现，立即执行一次，然后每 N 秒执行一次。如果N秒内触发则直接返回。</p>
<p data-v-md-line="840"><strong>应用</strong>：节流常应用于鼠标不断点击触发、监听滚动事件。</p>
<p data-v-md-line="842"><strong>实现</strong>:</p>
<div data-v-md-line="844"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-comment">// 版本一：标志实现</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>)</span>{
    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 设置一个标志</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>{
        <span class="hljs-keyword">if</span>(!flag) <span class="hljs-keyword">return</span>;
        flag = <span class="hljs-literal">false</span>;
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            fn.call(<span class="hljs-built_in">this</span>, ...args);
            flag = <span class="hljs-literal">true</span>;
        }, wait);
    }
}

<span class="hljs-comment">// 版本二：时间戳实现</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>{
    <span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>{
        <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
        <span class="hljs-keyword">if</span>(now - pre &lt; wait) <span class="hljs-keyword">return</span>;
        pre = now;
        fn.call(<span class="hljs-built_in">this</span>, ...args);
    }
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_11-instanceof" data-v-md-line="871">11. instanceof</h2>
<p data-v-md-line="873"><strong>作用</strong>：判断对象的具体类型。可以区别 <code>array</code> 和 <code>object</code>， <code>null</code> 和 <code>object</code> 等。</p>
<p data-v-md-line="875"><strong>语法</strong>：<code>A instanceof B</code></p>
<p data-v-md-line="877"><strong>如何判断的？</strong>: 如果B函数的显式原型对象在A对象的原型链上，返回<code>true</code>，否则返回<code>false</code>。</p>
<p data-v-md-line="879"><strong>注意</strong>：如果检测原始值，则始终返回 <code>false</code>。</p>
<p data-v-md-line="881"><strong>实现</strong>:</p>
<div data-v-md-line="883"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myinstanceof</span>(<span class="hljs-params">left, right</span>) </span>{
    <span class="hljs-comment">// 基本数据类型都返回 false，注意 typeof 函数 返回"function"</span>
    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">typeof</span> left !== <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> left !== <span class="hljs-string">"function"</span>) || left === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">let</span> leftPro = left.__proto__;  <span class="hljs-comment">// 取左边的（隐式）原型 __proto__</span>
    <span class="hljs-comment">// left.__proto__ 等价于 Object.getPrototypeOf(left)</span>
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
        <span class="hljs-comment">// 判断是否到原型链顶端</span>
        <span class="hljs-keyword">if</span>(leftPro === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-comment">// 判断右边的显式原型 prototype 对象是否在左边的原型链上</span>
        <span class="hljs-keyword">if</span>(leftPro === right.prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-comment">// 原型链查找</span>
        leftPro = leftPro.__proto__;
    }
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_12-深-浅拷贝" data-v-md-line="901">12. 深/浅拷贝</h2>
<p data-v-md-line="903">首先判断数据类型是否为对象，如果是对象（数组|对象），则递归（深/浅拷贝），否则直接拷贝。</p>
<div data-v-md-line="905"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">"object"</span> &amp;&amp; obj !== <span class="hljs-literal">null</span>;
}
复制代码
</code></pre>
</div></div><p data-v-md-line="912">这个函数只能判断 <code>obj</code> 是否是对象，无法判断其具体是数组还是对象。</p>
<h3 data-v-md-heading="_12-1-浅拷贝" data-v-md-line="914">12.1 浅拷贝</h3>
<div data-v-md-line="916"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-comment">// 这里只考虑对象类型</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowClone</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">if</span>(!isObject(obj)) <span class="hljs-keyword">return</span> obj;
    <span class="hljs-keyword">let</span> newObj = <span class="hljs-built_in">Array</span>.isArray(obj) ? [] : {};
    <span class="hljs-comment">// for...in 只会遍历对象自身的和继承的可枚举的属性（不含 Symbol 属性）</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {
        <span class="hljs-comment">// obj.hasOwnProperty() 方法只考虑对象自身的属性</span>
        <span class="hljs-keyword">if</span>(obj.hasOwnProperty(key)) {
            newObj[key] = obj[key];
        }
    }
    <span class="hljs-keyword">return</span> newObj;
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_12-2-深拷贝" data-v-md-line="933">12.2 深拷贝</h3>
<p data-v-md-line="935"><strong>实现一</strong>：不考虑 <code>Symbol</code></p>
<div data-v-md-line="937"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">if</span>(!isObject(obj)) <span class="hljs-keyword">return</span> obj;
    <span class="hljs-keyword">let</span> newObj = <span class="hljs-built_in">Array</span>.isArray(obj) ? [] : {};
    <span class="hljs-comment">// for...in 只会遍历对象自身的和继承的可枚举的属性（不含 Symbol 属性）</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {
        <span class="hljs-comment">// obj.hasOwnProperty() 方法只考虑对象自身的属性</span>
        <span class="hljs-keyword">if</span>(obj.hasOwnProperty(key)) {
            newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key];
        }
    }
    <span class="hljs-keyword">return</span> newObj;
}
复制代码
</code></pre>
</div></div><p data-v-md-line="953"><strong>实现二</strong>：考虑 <code>Symbol</code></p>
<div data-v-md-line="955"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-comment">// hash 作为一个检查器，避免对象深拷贝中出现环引用，导致爆栈</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) </span>{
    <span class="hljs-keyword">if</span>(!isObject(obj)) <span class="hljs-keyword">return</span> obj;
    <span class="hljs-comment">// 检查是有存在相同的对象在之前拷贝过，有则返回之前拷贝后存于hash中的对象</span>
    <span class="hljs-keyword">if</span>(hash.has(obj)) <span class="hljs-keyword">return</span> hash.get(obj);
    <span class="hljs-keyword">let</span> newObj = <span class="hljs-built_in">Array</span>.isArray(obj) ? [] : {};
    <span class="hljs-comment">// 备份存在hash中，newObj目前是空对象、数组。后面会对属性进行追加，这里存的值是对象的栈</span>
    hash.set(obj, newObj);
    <span class="hljs-comment">// Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</span>
    <span class="hljs-built_in">Reflect</span>.ownKeys(obj).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
        <span class="hljs-comment">// 属性值如果是对象，则进行递归深拷贝，否则直接拷贝</span>
        newObj[key] = isObject(obj[key]) ? deepClone(obj[key], hash) : obj[key];
    });
    <span class="hljs-keyword">return</span> newObj;
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_13-object-assign" data-v-md-line="974">13. Object.assign()</h2>
<p data-v-md-line="976"><strong>描述</strong>：<code>Object.assign()</code>方法用于将所有<strong>可枚举</strong>（<code>Object.propertyIsEnumerable()</code> 返回 <code>true</code>）和<strong>自有</strong>（<code>Object.hasOwnProperty()</code> 返回 <code>true</code>）属性的值从一个或多个源对象复制到目标对象。它将返回修改后的目标对象（请注意这个操作是浅拷贝）。</p>
<p data-v-md-line="978"><strong>实现</strong>：</p>
<div data-v-md-line="980"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Object</span>.assign = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, ...source</span>) </span>{
    <span class="hljs-keyword">if</span>(target == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Cannot convert undefined or null to object'</span>);
    }
    <span class="hljs-keyword">let</span> res = <span class="hljs-built_in">Object</span>(target);
    source.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
        <span class="hljs-keyword">if</span>(obj != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// for...in 只会遍历对象自身的和继承的可枚举的属性（不含 Symbol 属性）</span>
            <span class="hljs-comment">// hasOwnProperty 方法只考虑对象自身的属性</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {
                <span class="hljs-keyword">if</span>(obj.hasOwnProperty(key)) {
                    res[key] = obj[key];
                }
            }
        }
    });
    <span class="hljs-keyword">return</span> res;
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_14-object-is" data-v-md-line="1002">14. Object.is()</h2>
<p data-v-md-line="1004"><strong>描述</strong>：<code>Object.is</code> 不会转换被比较的两个值的类型，这点和<code>===</code>更为相似，他们之间也存在一些区别。</p>
<ol data-v-md-line="1006">
<li><code>NaN</code> 在 <code>===</code> 中是不相等的，而在 <code>Object.is</code> 中是相等的</li>
<li><code>+0</code>和<code>-0</code>在 <code>===</code> 中是相等的，而在 <code>Object.is</code> 中是不相等的</li>
</ol>
<p data-v-md-line="1009"><strong>实现</strong>：利用 <code>===</code></p>
<div data-v-md-line="1011"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Object</span>.is = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>{
    <span class="hljs-keyword">if</span>(x === y) {
        <span class="hljs-comment">// 当前情况下，只有一种情况是特殊的，即 +0 -0</span>
        <span class="hljs-comment">// 如果 x !== 0，则返回true</span>
        <span class="hljs-comment">// 如果 x === 0，则需要判断+0和-0，则可以直接使用 1/+0 === Infinity 和 1/-0 === -Infinity来进行判断</span>
        <span class="hljs-keyword">return</span> x !== <span class="hljs-number">0</span> || <span class="hljs-number">1</span> / x === <span class="hljs-number">1</span> / y;
    }
    <span class="hljs-comment">// x !== y 的情况下，只需要判断是否为NaN，如果x!==x，则说明x是NaN，同理y也一样</span>
    <span class="hljs-comment">// x和y同时为NaN时，返回true</span>
    <span class="hljs-keyword">return</span> x !== x &amp;&amp; y !== y;
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_15-发布订阅模式-事件总线" data-v-md-line="1026">15. 发布订阅模式(事件总线)</h2>
<p data-v-md-line="1028"><strong>描述</strong>：实现一个发布订阅模式，拥有 <code>on, emit, once, off</code> 方法</p>
<div data-v-md-line="1030"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitter</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// 包含所有监听器函数的容器对象</span>
    	<span class="hljs-comment">// 内部结构: {msg1: [listener1, listener2], msg2: [listener3]}</span>
        <span class="hljs-built_in">this</span>.cache = {};
    }
    <span class="hljs-comment">// 实现订阅</span>
    <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">name, callback</span>)</span> {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.cache[name]) {
            <span class="hljs-built_in">this</span>.cache[name].push(callback);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">this</span>.cache[name] = [callback];
        }
    }
    <span class="hljs-comment">// 删除订阅</span>
    <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">name, callback</span>)</span> {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.cache[name]) {
            <span class="hljs-built_in">this</span>.cache[name] = <span class="hljs-built_in">this</span>.cache[name].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item !== callback);
        }
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.cache[name].length === <span class="hljs-number">0</span>) <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.cache[name];
    }
    <span class="hljs-comment">// 只执行一次订阅事件</span>
    <span class="hljs-function"><span class="hljs-title">once</span>(<span class="hljs-params">name, callback</span>)</span> {
        callback();
        <span class="hljs-built_in">this</span>.off(name, callback);
    }
    <span class="hljs-comment">// 触发事件</span>
    <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">name, ...data</span>)</span> {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.cache[name]) {
            <span class="hljs-comment">// 创建副本，如果回调函数内继续注册相同事件，会造成死循环</span>
            <span class="hljs-keyword">let</span> tasks = <span class="hljs-built_in">this</span>.cache[name].slice();
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> fn <span class="hljs-keyword">of</span> tasks) {
                fn(...data);
            }
        }
    }
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_16-实现-jsonp-跨域" data-v-md-line="1072">16. 实现 JSONP 跨域</h2>
<p data-v-md-line="1074"><strong>JSONP 核心原理</strong>：<code>script</code> 标签不受同源策略约束，所以可以用来进行跨域请求，优点是兼容性好，但是只能用于 GET 请求；</p>
<p data-v-md-line="1076"><strong>实现</strong>：</p>
<div data-v-md-line="1078"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-keyword">const</span> jsonp = <span class="hljs-function">(<span class="hljs-params">url, params, callbackName</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> generateUrl = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">let</span> dataSrc = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) {
            <span class="hljs-keyword">if</span>(params.hasOwnProperty(key)) {
                dataSrc += <span class="hljs-string">`<span class="hljs-subst">${key}</span>=<span class="hljs-subst">${params[key]}</span>&amp;`</span>
            }
        }
        dataSrc += <span class="hljs-string">`callback=<span class="hljs-subst">${callbackName}</span>`</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${url}</span>?<span class="hljs-subst">${dataSrc}</span>`</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> scriptEle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);
        scriptEle.src = generateUrl();
        <span class="hljs-built_in">document</span>.body.appendChild(scriptEle);
        <span class="hljs-built_in">window</span>[callbackName] = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
            resolve(data);
            <span class="hljs-built_in">document</span>.removeChild(scriptEle);
        }
    });
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_17-ajax" data-v-md-line="1103">17. AJAX</h2>
<p data-v-md-line="1105"><strong>实现</strong>：利用 <code>XMLHttpRequest</code></p>
<div data-v-md-line="1107"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-comment">// get</span>
<span class="hljs-keyword">const</span> getJSON = <span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
        <span class="hljs-comment">// open 方法用于指定 HTTP 请求的参数: method, url, async（是否异步，默认true）</span>
        xhr.open(<span class="hljs-string">"GET"</span>, url, <span class="hljs-literal">false</span>);
        xhr.setRequestHeader(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'application/json'</span>);
        <span class="hljs-comment">// onreadystatechange 属性指向一个监听函数。</span>
        <span class="hljs-comment">// readystatechange 事件发生时（实例的readyState属性变化），就会执行这个属性。</span>
        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-comment">// 4 表示服务器返回的数据已经完全接收，或者本次接收已经失败</span>
            <span class="hljs-keyword">if</span>(xhr.readyState !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;
            <span class="hljs-comment">// 请求成功，基本上只有2xx和304的状态码，表示服务器返回是正常状态</span>
            <span class="hljs-keyword">if</span>(xhr.status === <span class="hljs-number">200</span> || xhr.status === <span class="hljs-number">304</span>) {
                <span class="hljs-comment">// responseText 属性返回从服务器接收到的字符串</span>
                resolve(xhr.responseText);
            }
            <span class="hljs-comment">// 请求失败</span>
            <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(xhr.responseText));
            }
        }
        xhr.send();
    });
}

<span class="hljs-comment">// post</span>
<span class="hljs-keyword">const</span> postJSON = <span class="hljs-function">(<span class="hljs-params">url, data</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
        xhr.open(<span class="hljs-string">"POST"</span>, url);
        xhr.setRequestHeader(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'application/x-www-form-urlencoded'</span>);
        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-keyword">if</span>(xhr.readyState !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">if</span>(xhr.status === <span class="hljs-number">200</span> || xhr.status === <span class="hljs-number">304</span>) {
                resolve(xhr.responseText);
            }
            <span class="hljs-keyword">else</span> {
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(xhr.responseText));
            }
        }
        xhr.send(data);
    });
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_18-promise" data-v-md-line="1155">18. Promise</h2>
<p data-v-md-line="1157">Promise的实现参考如下链接</p>
<ol data-v-md-line="1159">
<li><a href="https://juejin.cn/post/6945319439772434469" target="_blank">从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a></li>
<li><a href="https://juejin.cn/post/7043758954496655397" target="_blank">手把手一行一行代码教你“手写Promise“，完美通过 Promises/A+ 官方872个测试用例</a></li>
</ol>
<h3 data-v-md-heading="_18-1-promise-resolve" data-v-md-line="1162">18.1 Promise.resolve</h3>
<div data-v-md-line="1164"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Promise</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-comment">// 1.如果 value 参数是一个 Promise 对象，则原封不动返回该对象</span>
    <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) <span class="hljs-keyword">return</span> value;
    <span class="hljs-comment">// 2.如果 value 参数是一个具有 then 方法的对象，则将这个对象转为 Promise 对象，并立即执行它的then方法</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-string">'then'</span> <span class="hljs-keyword">in</span> value) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
           value.then(resolve, reject);
        });
    }
    <span class="hljs-comment">// 3.否则返回一个新的 Promise 对象，状态为 fulfilled</span>
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(value));
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_18-2-promise-reject" data-v-md-line="1180">18.2 Promise.reject</h3>
<div data-v-md-line="1182"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Promise</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(reason));
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_18-3-promise-all" data-v-md-line="1189">18.3 Promise.all</h3>
<p data-v-md-line="1191"><strong>描述</strong>：所有 <code>promise</code> 的状态都变成 <code>fulfilled</code>，就会返回一个状态为 <code>fulfilled</code> 的数组(所有<code>promise</code> 的 <code>value</code>)。只要有一个失败，就返回第一个状态为 <code>rejected</code> 的 <code>promise</code> 实例的 <code>reason</code>。</p>
<p data-v-md-line="1193"><strong>实现</strong>：</p>
<div data-v-md-line="1195"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(promises)) {
            <span class="hljs-keyword">if</span>(promises.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> resolve(promises);
            <span class="hljs-keyword">let</span> result = [];
            <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
            promises.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {
                <span class="hljs-built_in">Promise</span>.resolve(item).then(
                    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
                        count++;
                        result[index] = value;
                        <span class="hljs-keyword">if</span>(count === promises.length) resolve(result);
                    }, 
                    <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> reject(reason)
                );
            })
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Argument is not iterable"</span>));
    });
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_18-4-promise-allsettled" data-v-md-line="1219">18.4 Promise.allSettled</h3>
<p data-v-md-line="1221"><strong>描述</strong>：等到所有<code>promise</code>都返回结果，就返回一个<code>promise</code>实例。</p>
<p data-v-md-line="1223"><strong>实现</strong>：</p>
<div data-v-md-line="1225"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Promise</span>.allSettled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(promises)) {
            <span class="hljs-keyword">if</span>(promises.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> resolve(promises);
            <span class="hljs-keyword">let</span> result = [];
            <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
            promises.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {
                <span class="hljs-built_in">Promise</span>.resolve(item).then(
                    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
                        count++;
                        result[index] = {
                            <span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>,
                            <span class="hljs-attr">value</span>: value
                        };
                        <span class="hljs-keyword">if</span>(count === promises.length) resolve(result);
                    }, 
                    <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {
                        count++;
                        result[index] = {
                            <span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>.
                            <span class="hljs-attr">reason</span>: reason
                        };
                        <span class="hljs-keyword">if</span>(count === promises.length) resolve(result);
                    }
                );
            });
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Argument is not iterable"</span>));
    });
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_18-5-promise-race" data-v-md-line="1259">18.5 Promise.race</h3>
<p data-v-md-line="1261"><strong>描述</strong>：只要<code>promises</code>中有一个率先改变状态，就返回这个率先改变的<code>Promise</code>实例的返回值。</p>
<p data-v-md-line="1263"><strong>实现</strong>：</p>
<div data-v-md-line="1265"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Promise</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(promises)) {
            <span class="hljs-keyword">if</span>(promises.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> resolve(promises);
            promises.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
                <span class="hljs-built_in">Promise</span>.resolve(item).then(
                    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> resolve(value), 
                    <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> reject(reason)
                );
            })
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Argument is not iterable"</span>));
    });
}
复制代码
</code></pre>
</div></div><h3 data-v-md-heading="_18-6-promise-any" data-v-md-line="1283">18.6 Promise.any</h3>
<p data-v-md-line="1285"><strong>描述</strong>：只要 <code>promises</code> 中有一个<code>fulfilled</code>，就返回第一个<code>fulfilled</code>的<code>Promise</code>实例的返回值。</p>
<p data-v-md-line="1287"><strong>实现</strong></p>
<div data-v-md-line="1289"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-built_in">Promise</span>.any = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(promises)) {
            <span class="hljs-keyword">if</span>(promises.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> AggregateError(<span class="hljs-string">"All promises were rejected"</span>));
            <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
            promises.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {
                <span class="hljs-built_in">Promise</span>.resolve(item).then(
                    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> resolve(value),
                    <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {
                        count++;
                        <span class="hljs-keyword">if</span>(count === promises.length) {
                            reject(<span class="hljs-keyword">new</span> AggregateError(<span class="hljs-string">"All promises were rejected"</span>));
                        };
                    }
                );
            })
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Argument is not iterable"</span>));
    });
}
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_19-异步任务调度器" data-v-md-line="1313">19. 异步任务调度器</h2>
<p data-v-md-line="1315"><strong>描述</strong>：实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有 <code>limit</code> 个。</p>
<p data-v-md-line="1317"><strong>实现</strong>：</p>
<div data-v-md-line="1319"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scheduler</span> </span>{
    queue = [];  <span class="hljs-comment">// 用队列保存正在执行的任务</span>
    runCount = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 计数正在执行的任务个数</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">limit</span>)</span> {
        <span class="hljs-built_in">this</span>.maxCount = limit;  <span class="hljs-comment">// 允许并发的最大个数</span>
    }
    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">time, data</span>)</span>{
        <span class="hljs-keyword">const</span> promiseCreator = <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                    <span class="hljs-built_in">console</span>.log(data);
                    resolve();
                }, time);
            });
        }
        <span class="hljs-built_in">this</span>.queue.push(promiseCreator);
        <span class="hljs-comment">// 每次添加的时候都会尝试去执行任务</span>
        <span class="hljs-built_in">this</span>.request();
    }
    <span class="hljs-function"><span class="hljs-title">request</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// 队列中还有任务才会被执行</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.queue.length &amp;&amp; <span class="hljs-built_in">this</span>.runCount &lt; <span class="hljs-built_in">this</span>.maxCount) {
            <span class="hljs-built_in">this</span>.runCount++;
            <span class="hljs-comment">// 执行先加入队列的函数</span>
            <span class="hljs-built_in">this</span>.queue.shift()().then(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-built_in">this</span>.runCount--;
                <span class="hljs-comment">// 尝试进行下一次任务</span>
                <span class="hljs-built_in">this</span>.request();
            });
        }
    }
}

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">const</span> scheduler = <span class="hljs-keyword">new</span> Scheduler(<span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> addTask = <span class="hljs-function">(<span class="hljs-params">time, data</span>) =&gt;</span> {
    scheduler.add(time, data);
}

addTask(<span class="hljs-number">1000</span>, <span class="hljs-string">'1'</span>);
addTask(<span class="hljs-number">500</span>, <span class="hljs-string">'2'</span>);
addTask(<span class="hljs-number">300</span>, <span class="hljs-string">'3'</span>);
addTask(<span class="hljs-number">400</span>, <span class="hljs-string">'4'</span>);
<span class="hljs-comment">// 输出结果 2 3 1 4</span>
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_20-settimeout-模拟-setinterval" data-v-md-line="1367">20. setTimeout 模拟 setInterval</h2>
<p data-v-md-line="1369"><strong>描述</strong>：使用<code>setTimeout</code>模拟实现<code>setInterval</code>的功能。</p>
<p data-v-md-line="1371"><strong>实现</strong>：</p>
<div data-v-md-line="1373"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-keyword">const</span> <span class="hljs-function"><span class="hljs-title">mySetInterval</span>(<span class="hljs-params">fn, time</span>)</span> {
    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> interval = <span class="hljs-function">() =&gt;</span> {
        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            fn();  <span class="hljs-comment">// time 时间之后会执行真正的函数fn</span>
            interval();  <span class="hljs-comment">// 同时再次调用interval本身</span>
        }, time)
    }
    interval();  <span class="hljs-comment">// 开始执行</span>
    <span class="hljs-comment">// 返回用于关闭定时器的函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(timer);
}

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">const</span> cancel = mySetInterval(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>), <span class="hljs-number">400</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    cancel();
}, <span class="hljs-number">1000</span>);  
<span class="hljs-comment">// 打印两次1</span>
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_21-setinterval-模拟-settimeout" data-v-md-line="1396">21. setInterval 模拟 setTimeout</h2>
<p data-v-md-line="1398"><strong>描述</strong>：使用<code>setInterval</code>模拟实现<code>setTimeout</code>的功能。</p>
<p data-v-md-line="1400"><strong>思路</strong>：<code>setTimeout</code>的特性是在指定的时间内只执行一次，我们只要在<code>setInterval</code>内部执行 <code>callback</code> 之后，把定时器关掉即可。</p>
<p data-v-md-line="1402"><strong>实现</strong>：</p>
<div data-v-md-line="1404"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-keyword">const</span> mySetTimeout = <span class="hljs-function">(<span class="hljs-params">fn, time</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;
    timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// 关闭定时器，保证只执行一次fn，也就达到了setTimeout的效果了</span>
        <span class="hljs-built_in">clearInterval</span>(timer);
        fn();
    }, time);
    <span class="hljs-comment">// 返回用于关闭定时器的方法</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);
}

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">const</span> cancel = mySetTimeout(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);
}, <span class="hljs-number">1000</span>);  
<span class="hljs-comment">// 一秒后打印 1</span>
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_22-图片懒加载" data-v-md-line="1424">22. 图片懒加载</h2>
<p data-v-md-line="1426"><strong>实现</strong>：<code>getBoundClientRect</code> 的实现方式，监听 <code>scroll</code> 事件（建议给监听事件添加节流），图片加载完会从 <code>img</code> 标签组成的 DOM 列表中删除，最后所有的图片加载完毕后需要解绑监听事件。</p>
<div data-v-md-line="1428"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-comment">// scr 加载默认图片，data-src 保存实施懒加载后的图片</span>
<span class="hljs-comment">// &lt;img src="./default.jpg" data-src="https://xxx.jpg" alt="" /&gt;</span>
<span class="hljs-keyword">let</span> imgs = [...document.querySelectorAll(<span class="hljs-string">"img"</span>)];
<span class="hljs-keyword">const</span> len = imgs.length;

<span class="hljs-keyword">let</span> lazyLoad = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> deleteImgs = [];
    <span class="hljs-comment">// 获取当前可视区的高度</span>
    <span class="hljs-keyword">let</span> viewHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight;
    <span class="hljs-comment">// 获取当前滚动条的位置(距离顶部的距离,等价于document.documentElement.scrollTop)</span>
    <span class="hljs-keyword">let</span> scrollTop = <span class="hljs-built_in">window</span>.pageYOffset;
    imgs.forEach(<span class="hljs-function">(<span class="hljs-params">img</span>) =&gt;</span> {
        <span class="hljs-comment">// 获取元素的大小，及其相对于视口的位置，如 bottom 为元素底部到网页顶部的距离</span>
        <span class="hljs-keyword">let</span> bound = img.getBoundingClientRect();
        <span class="hljs-comment">// 当前图片距离网页顶部的距离</span>
        <span class="hljs-comment">// let imgOffsetTop = img.offsetTop;</span>
        
        <span class="hljs-comment">// 判断图片是否在可视区内，如果在就加载（两种判断方式）</span>
        <span class="hljs-comment">// if(imgOffsetTop &lt; scrollTop + viewHeight) </span>
        <span class="hljs-keyword">if</span> (bound.top &lt; viewHeight) {
            img.src = img.dataset.src;  <span class="hljs-comment">// 替换待加载的图片 src</span>
            count++;
            deleteImgs.push(img);
            <span class="hljs-comment">// 最后所有的图片加载完毕后需要解绑监听事件</span>
            <span class="hljs-keyword">if</span>(count === len) {
                <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">"scroll"</span>, imgThrottle);
            }
        }
    });
    <span class="hljs-comment">// 图片加载完会从 `img` 标签组成的 DOM 列表中删除</span>
    imgs = imgs.filter(<span class="hljs-function">(<span class="hljs-params">img</span>) =&gt;</span> !deleteImgs.includes(img));
}

<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    lazyLoad();
};
<span class="hljs-comment">// 使用 防抖/节流 优化一下滚动事件</span>
<span class="hljs-keyword">let</span> imgThrottle = debounce(lazyLoad, <span class="hljs-number">1000</span>);
<span class="hljs-comment">// 监听 `scroll` 事件</span>
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"scroll"</span>, imgThrottle);
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_23-虚拟dom转换成真实dom" data-v-md-line="1473">23. 虚拟DOM转换成真实DOM</h2>
<p data-v-md-line="1475"><strong>描述</strong>：将如下 JSON格式的<strong>虚拟DOM</strong>结构转换成<strong>真实DOM</strong>结构。</p>
<div data-v-md-line="1477"><div class="v-md-pre-wrapper v-md-pre-wrapper-JSON extra-class"><pre class="v-md-hljs-JSON"><code>// vnode 结构
{
    tag: 'DIV',
    attrs: {
        id: "app"
    },
    children: [
        {
            tag: 'SPAN',
            children: [
                {
                    tag: 'A',
                    children: []
                }
            ]
        }
    ]
}
// 真实DOM 结构
&lt;div id="app"&gt;
    &lt;span&gt;
        &lt;a&gt;&lt;/a&gt;
    &lt;/span&gt;
&lt;/div&gt;
复制代码
</code></pre>
</div></div><p data-v-md-line="1505"><strong>实现</strong>：</p>
<div data-v-md-line="1507"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_render</span>(<span class="hljs-params">vnode</span>) </span>{
    <span class="hljs-comment">// 如果是数字类型转化为字符串；</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> vnode === <span class="hljs-string">"number"</span>) {
        vnode = <span class="hljs-built_in">String</span>(vnode);
    }
    <span class="hljs-comment">// 字符串类型直接就是文本节点</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> vnode === <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createTextNode(vnode);
    }
    <span class="hljs-comment">// 普通 DOM</span>
    <span class="hljs-keyword">const</span> dom = <span class="hljs-built_in">document</span>.createElement(vnode.tag);
    <span class="hljs-keyword">if</span>(vnode.attrs) {
        <span class="hljs-comment">// 遍历属性</span>
        <span class="hljs-built_in">Object</span>.keys(vnode.attrs).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {
            dom.setAttribute(key, vnode.attrs[key]);
        });
    }
    <span class="hljs-comment">// 子数组进行递归操作</span>
    vnode.children.forEach(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> dom.appendChild(_render(child)));
    <span class="hljs-keyword">return</span> dom;
}

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">let</span> vnode = {
    <span class="hljs-attr">tag</span>: <span class="hljs-string">"DIV"</span>,
    <span class="hljs-attr">attrs</span>: {
        <span class="hljs-attr">id</span>: <span class="hljs-string">"app"</span>,
    },
    <span class="hljs-attr">children</span>: [
        {
            <span class="hljs-attr">tag</span>: <span class="hljs-string">"SPAN"</span>,
            <span class="hljs-attr">children</span>: [
                {
                    <span class="hljs-attr">tag</span>: <span class="hljs-string">"A"</span>,
                    <span class="hljs-attr">children</span>: [],
                },
            ],
        },
    ],
};
<span class="hljs-built_in">console</span>.log(_render(vnode)); <span class="hljs-comment">// &lt;div id="app"&gt;&lt;span&gt;&lt;a&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;</span>
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_24-实现模板字符串解析" data-v-md-line="1552">24. 实现模板字符串解析</h2>
<p data-v-md-line="1554"><strong>描述</strong>：实现函数使得将 <code>template</code> 字符串中的<code>{{}}</code>内的变量替换。</p>
<p data-v-md-line="1556"><strong>核心</strong>：使用字符串替换方法 <code>str.replace(regexp|substr, newSubStr|function)</code>，使用正则匹配代换字符串。</p>
<p data-v-md-line="1558"><strong>实现</strong>：</p>
<div data-v-md-line="1560"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">template, data</span>) </span>{
    <span class="hljs-comment">// 模板字符串正则 /\{\{(\w+)\}\}/, 加 g 为全局匹配模式, 每次匹配都会调用后面的函数</span>
    <span class="hljs-keyword">let</span> computed = template.replace(<span class="hljs-regexp">/\{\{(\w+)\}\}/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">match, key</span>) </span>{
        <span class="hljs-comment">// match: 匹配的子串;  key：括号匹配的字符串</span>
        <span class="hljs-keyword">return</span> data[key];
    });
    <span class="hljs-keyword">return</span> computed;
}

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">let</span> template = <span class="hljs-string">"我是{{name}}，年龄{{age}}，性别{{sex}}"</span>;
<span class="hljs-keyword">let</span> data = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"张三"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>
}
<span class="hljs-built_in">console</span>.log(render(template, data)); <span class="hljs-comment">// 我是张三，年龄18，性别undefined</span>
复制代码
</code></pre>
</div></div><h2 data-v-md-heading="_25-单例模式" data-v-md-line="1580">25. 单例模式</h2>
<p data-v-md-line="1582"><strong>意图</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p data-v-md-line="1584"><strong>主要解决</strong>：一个全局使用的类频繁地创建与销毁。</p>
<p data-v-md-line="1586"><strong>何时使用</strong>：当您想控制实例数目，节省系统资源的时候。</p>
<p data-v-md-line="1588"><strong>如何解决</strong>：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p data-v-md-line="1590"><strong>实现</strong>：</p>
<div data-v-md-line="1592"><div class="v-md-pre-wrapper v-md-pre-wrapper-js extra-class"><pre class="v-md-hljs-js"><code><span class="hljs-keyword">var</span> Singleton = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 如果在内部声明 SingletonClass 对象，则无法在外部直接调用</span>
    <span class="hljs-keyword">var</span> SingletonClass = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ }; 
    <span class="hljs-keyword">var</span> instance;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// 如果已存在，则返回 instance</span>
        <span class="hljs-keyword">if</span>(instance) <span class="hljs-keyword">return</span> instance;
        <span class="hljs-comment">// 如果不存在，则new 一个 SingletonClass 对象</span>
        instance = <span class="hljs-keyword">new</span> SingletonClass();
        <span class="hljs-keyword">return</span> instance;
    }
})();

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Singleton();
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Singleton();
<span class="hljs-built_in">console</span>.log(a === b);  <span class="hljs-comment">// true</span>
</code></pre>
</div></div><p data-v-md-line="1614">作者：JIANGA<br>
链接：https://juejin.cn/post/7105323100341796901<br>
来源：稀土掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
